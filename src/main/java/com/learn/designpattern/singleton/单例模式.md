# 单例模式(Singleton Pattern)

## 定义

确保一个类在任何情况下都绝对只有一个实例，并提供全局访问点。

## 应用场景

1. 需要频繁创建的类，使用单例模式降低系统内存压力，减少GC
2. 某些类创建实例占用资源较多，或实例化耗时较长，且经常使用。
3. 频繁访问数据库或文件的对象。
4. 对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统完全乱套。



## 实现方式

### 饿汉式

```java
public class HungryStaticSingleton {


    /**
     * 实例常量
     */
    private static final HungryStaticSingleton INSTANCE;

    //实例初始化
    static {
        INSTANCE = new HungryStaticSingleton();
    }

    private HungryStaticSingleton(){

    }

    /**
     * 返回单例对象
     * @return 对象
     */
    public static HungryStaticSingleton getInstance() {
        return INSTANCE;
    }
}
```

####  特点

1. 线程安全，类加载时实例单例对象。
2. 导致系统初始化速度慢。





### 懒汉式

```java
public class LazySimpleSingleton {

    /**
     * 单例对象
     */
    private static LazySimpleSingleton INSTANCE;


    /**
     * 私有化构造函数
     */
    private LazySimpleSingleton() {

    }

    /**
     * 获取单例对象
     *
     * @return 单例对象
     */
    public static LazySimpleSingleton getInstance() {
        if (INSTANCE == null) {
            //在此加断点，进行模拟线程中断
            INSTANCE = new LazySimpleSingleton();
        }

        return INSTANCE;
    }

}
```

### 特点

1. 线程不安全(会出现两个线程同事进入getInstance方法，且同时满足if(null==instance));，同时进行对象创建，导致出现多个对象。


### 双重检测锁-懒汉式

```java
public class LazyDoubleCheckSingleton {

    /**
     * 实例
     */
    private static LazyDoubleCheckSingleton INSTANCE;
    
    private LazyDoubleCheckSingleton() {
        
    }

    /**
     * 获取实例
     * @return 单例实例
     */
    public static LazyDoubleCheckSingleton getInstance() {
        if (null == INSTANCE) {
            synchronized (LazyDoubleCheckSingleton.class) {
                if (null == INSTANCE) {
                    INSTANCE = new LazyDoubleCheckSingleton();
                }
            }
        }

        return INSTANCE;
    }

    
    
}

```

### 特点

1. 线程安全

